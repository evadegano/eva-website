---
title: 'How to prepare for your technical interview?'
date: '2022-02-28'
tags: 'starting as a programmer'
---
import EmbedYTVid from '../components/jsx/embedYTVid';

Technical interviews are hands down the most stressful thing for a junior Web Developer.

They can take a few different shapes: showing a project you're proud of, doing a home assignment, answering technical questions, or solving a coding challenge.

The latter is rightly the most dreaded, but with the right strategy, not only will you feel ready to take up on that challenge, you'll also feel excited as hell to put your new algo-solving skills to the test!

And you know what, the right strategy is exactly what I'm going to give you in this post.

## 1. The right mindset
If you've read some of my posts before, you know that training your mind is always even more important than training your skills.

So here's what I want you to do during this training: 
- Fight your brain’s initial instinct to freeze and panic. Tell yourself it's alright, there's no reason to panic. Then regroup and focus on dissecting the problem methodically. No need to find the whole solution right away, go step by step.
- Remember that the problem is always easier than it first seems. The wording is often made to mindf*ck you. But the content is always the same. Once you've learnt a few different patterns, you'll have a toolset to choose from.
- Try to approach it in a way that’s fun for you (ex: like a riddle).

## 2. Common complexities
Read this cheat sheet once to make sure you remember common complexities:
https://craigndave.org/wp-content/uploads/2020/09/big-o-notation-cheat-sheet.pdf

Then when you practice with coding exercices, keep it by your side and use it to figure out your solutions' complexities.

## 3. Recursive thinking
Recursions are when a function or some other subprogram calls itself.

"Wtf" is what you usually say to yourself the first time you see encouter them.

But do not panic!
With a bit of practice - about 10 hours of it - recursions will start making sense.

And you'll see how f*cking cool they are. Recursion is this thing that makes you answer problems elegantly and feel proud about your problem-solving skills.

Here are 2 videos that helped me finally understand recursions:

<EmbedYTVid url={'https://www.youtube.com/embed/oKndim5-G94'} />

<EmbedYTVid url={'https://www.youtube.com/embed/ngCos392W4w'} />

In a nutshell:
- Avoid thinking about recursion at all
- Start by solving the problem for the simplest input possible to understand the underlying mechanics. 
This will make things easier and give you your base cases.

## 4. The main data structures and their operations

From what I've seen, there are many different data structures out there.

But as a junior web dev, I feel like you can get away with knowing just a few of them.

If you don't know what 
<a href='https://www.youtube.com/watch?v=A3ZUpyrnCbM' target='_blank'>stacks and queues</a> and 
<a href='https://www.youtube.com/watch?v=sfWyugl4JWA&t=790s' target='_blank'>arrays and dictionaries</a>
are, start by checking them out :)

Once you have, move on to the next videos. Make sure you pause them and try to do the exercices before moving on to the solution.

I also recommend you do the

### Linked lists
<EmbedYTVid url={'https://www.youtube.com/embed/Hj_rA0dhr2I'} />

### Binary trees
<EmbedYTVid url={'https://www.youtube.com/embed/fAAZixBzIAI'} />

### Graphs
<EmbedYTVid url={'https://www.youtube.com/embed/tWVWeAqZ0WU'} />

## 4. Common searching and sorting algorithms

While data structure are ways to store and organize data, algorithms process that data and perform calculations to find a solution to a problem.

Searching and sorting algorithms are important because they operate such a basic and common task. If you think about it, I'm sure you use them almost everyday.

Thus efficient sorting is important for optimizing the efficiency of other algorithms.

Even though you'll probably often use built-in searching and sorting functions, it's still very useful to understand how they work under the hood and how they impact performance.

The four-part series below will teach you everything to need as a junior dev to feel coomfortable about searching and sorting algorithms:
<EmbedYTVid url={'https://www.youtube.com/embed/g2bQgaLxq_s'} />

## 5. Dynamic programming
Dynamic Programming is an algorithmic technique that allows to optimize (aka reduce the complexity) of recursive functions that have repeated calls for same inputs (like Fibonacci).

So whenever you see one of those, think about DP!

And you'll see that the idea is quite simple: it's all about storing the results of subproblems to avoid re-computing them. It's easy enough and allows us to reduce time complexities from exponential to polynomial.

There are two dynamic programming methods:
- Memoization: when we solve a sub-problem, we cache its result so that when it's called again, we return the saved result instead of solving it again.
- Tabulation: we solve all sub-problems to fill up an n-dimensional table, and then compute the solution to the top, original problem.

Here's a video that will clarify everything for you:
<EmbedYTVid url={'https://www.youtube.com/embed/oBt53YbR9Kk'} />


## 6. Practice practice practice
Alright, now the real fun begins!

Resolving algorithmic problems may seem super annoying at first, but after a few exercices, you'll see that this is by far the most rewarding step.

At a certain point, your brain will start to 'get it' and everything will become obvious.

However, with all the coding practice websites out there, which one should you choose?

In my experience, avoid Codewars! There are way too many problems and most of them kinda suck.
Instead, go for a platform that has a more curated content.

If you're willing to pay, I strongly recommend you use [Structy](https://structy.net/) or [AlgoExpert](https://www.algoexpert.io/product).
As it was designed for the sole purpose of helping you ace your technical interview, it will save you a lot of time and energy.

If you wan't to go the free route, try [HackerRank](https://www.hackerrank.com/) or [LeetCode](https://leetcode.com/).
